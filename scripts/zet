#!/bin/sh
## my own `zet` command in the making
declare red=$'\033[31m'                                                         
declare black=$'\033[30m'                                                       
declare green=$'\033[32m'                                                       
declare yellow=$'\033[33m'                                                      
declare blue=$'\033[34m'                                                        
declare magenta=$'\033[35m'                                                     
declare cyan=$'\033[36m'                                                        
declare white=$'\033[37m'                                                       
declare reset=$'\033[0m'                                                        
declare bold=$'\033[1m'  
declare zetdir="$ZETDIR" #if zpc = zet private create, switch to private dir

#set -e                                                                          
shopt -s extglob

_isosec() { date -u +%Y%m%d%H%M%S; }


__create() {
  ## create file
  local dir="$zetdir/$(_isosec)" #absolute path
  #dir="$(x.dir)/$(x.isosec)" #TODO initial confifile that stores public/private zet dir
  local readme="$dir/README.md" #absolute path
  local title="$*" 
  ##TODO WHY not just use title, whats the point of line variable???J
  mkdir -p "$dir"
  printf "# %s\n\n" "$title" > "$readme"
  ## edit file
  _createEditFile
  ## push file to remote git repo
  _createAddGit
} 

_createEditFile() { "$EDITOR" "$readme" ; }
_createAddGit() {
  local listCreatedReadme="$(git ls-files --others --exclude-standard)"
  ## check if readme exists, if not abort git commands
  [[ "$readme" =~ "$listCreatedReadme" ]] || return 1
  ## check if readme is empty, if so abort git commands
  [[ -s "$readme" ]] || return 1
  exit
  cd "$dir" &>/dev/null
  local line=$(head -1 "$readme" | sed 's|#\+ *||')
  test -n "$line"
  git pull -q
  echo "${green}Committing:$reset ${bold}$line${reset}"
  git add -A "$dir" &>/dev/null
  git commit -m "$line" &>/dev/null
  git push &>/dev/null
}



## fzf functions to edit files
##TODO after edit push files to git
##TODO check if `git status` shows changes if so auto commit them with
#title as commit msg
__edit() {
  ## filter and merge lines
  local -a mergeTitleTag=()
  local -i i=0
  for f in "$zetdir"/*; do 
    filterLastLine="$(tail -n 1 "$f"/README.md 2>/dev/null)"
    filterFirstLine="$(head -n1 "$f"/README.md 2>/dev/null)"
    #echo "$(tail -n 1 "$f"/README.md 2>/dev/null)"
    mergeTitleTag[$i]="$filterFirstLine"
    if [[ "$filterLastLine" =~ ^[[:blank:]]{4}\#.*$ ]]; then
      mergeTitleTag[$i]+="$filterLastLine"
    fi
    i+=1
  done
  ## fzf select title with tags at the end of title
  _editSelectTitle
}
_editSelectTitle() {
  local selectTitle="$(for element in "${mergeTitleTag[@]}"; do               \
    echo "$element"; done                                                     \
    | fzf --no-preview      `#pipe each Title and possible Taline into fzf` \
    | sed -r 's|[[:blank:]]{4}#[a-z].*$||g')" `#remove the tags from string`
  #echo "$selectTitle"
  ## edit file from fzf selection
  _editEditFile
}
_editEditFile() {
  local dir="$(rg --no-heading -N "^""$selectTitle""$" "$zetdir" | sed 's|/README.md:.*||g')"
  local readme="$dir/README.md" #absolute path
  #echo "$readme"
  "$EDITOR" "$readme"
  _editAddGit
  
  #_editAddGit
}

_editAddGit() {
  ## check if readme modified if not abort git commands
  local listModifiedReadme="$(git ls-files --modified)"
  #echo $listModifiedReadme
  #echo $readme
  [[ "$readme" =~ "$listModifiedReadme" ]] || return 1
  cd "$dir" &>/dev/null

  local line=$(head -1 "$readme" | sed 's|#\+ *||')
  echo $line
  exit 2
  test -n "$line"
  git pull -q
  echo "${green}Committing:$reset ${bold}$line${reset}"
  git add -A "$dir" &>/dev/null
  git commit -m "$line" &>/dev/null
  git push &>/dev/null
}

case "$1" in
  create) __create "${@:2}";; #pass all parameters except $0,$1
  edit) __edit;;
  *)
esac
